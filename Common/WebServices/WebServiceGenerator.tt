<#@ include file="WebServiceGeneration.tt" #>

<#
//  Instructions for adding to/modifying an existing web service:
//    Modify the "I{Module}Service.tt" file, adding/editing lines in the Generate() function call.
//    Only one parameter and one return type is allowed.  The parameter is optional.  The return type 
//    is required.
//    Use a container class if multiple needed. Container classes go in a separate C# file.  This
//    file must be linked to from the Silverlight project.
//
//
//  Instructions for creating a new web service.  NOTE:  In these instructions, I added a space between 
//  the T4 special character sequences < #, # > because these comments cannot contain the sequences or
//  T4 will try to interpret.  You will need to remove the space when copying to actual code.
//
//  Server side:
//    1. Create a .NET class library project to contain the web service implementation code (called 
//       "{Module}").
//    2. Add a reference to these assemblies:  System.ServiceModel
//    3. Add a TextTemplate file under that project called "IWebService.tt".  Replace its contents with:
//          < #@ include file="..\Services\Web\WebServiceGenerator.tt" # >
//          < #
//              Generate("{Module Namespace}", "WebService", new WebService 
//              {
//                  { "{Function}", "{Parameter Type}", "{Return Type}" }
//              });
//          # >
//       Don't forget to remove space between < # and # >.  Replace {} expressions as appropriate.
//       The relative path to WebServiceGenerator.tt will need to be modified (probably more ..\'s).
//       See notes above for adding/modifying an existing web service.
//    4. Create a C# class file called "WebService.cs" for the web service implementation.
//       The class must be named "WebService" and implement "IWebServiceContract".  Use
//       the VS refactor function to create the function signature(s) for you.
//       Add this attribute the to class:  
//         [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]        
//
//  Client (Silverlight) side:
//    1. Create a Silverlight class library project called "{Module}".
//    2. Add a reference to these assemblies/projects:  System.ServiceModel, Gongchengshi.Silverlight
//    3. Add a link to the "IWebService.cs" file (the one generated by T4) in the .NET project, 
//       and a link to the container class file if used.
//    4. From Silverlight view-model code, use the WebServiceClient.Instance method to access
//       (defined in the .tt generated file) and call its asynchronous 
//       functions. You'll need to add the appropriate using statements.
//
//  Main .Web Project:
//    1. Add a reference to the .NET "{Module}" project.
//    2. Add a .svc file with the following contents.  Just use the "Text File" template in VS New Item... 
//         <%@ ServiceHost Debug="true" Service="{Module Namespace}.WebService"%>
//       The Service="" argument must contain the namespace and name of the class (matching the arguments
//       to Generate() in the .tt file).  Example:  Gongchengshi.CoolModule.WebService
//    3. Edit Web.config and add a service and a binding.
//       Service:
//         <service name="{Module Namespace}.WebService">
//            <endpoint address="" binding="customBinding" bindingConfiguration=
//              "{Module Namespace}.WebService.customBinding"
//              contract="{Module Namespace}.IWebServiceContract" />
//            <endpoint address="mex" binding="mexHttpBinding" contract="IMetadataExchange" />
//         </service>
//       Binding:
//         <binding name="{Module Namespace}.WebService.customBinding">
//           <binaryMessageEncoding />
//           <httpTransport />
//         </binding>
//
//  Creating a Mock for testing Silverlight code:
//    1. Create a mock class that subclasses "I{Module}ServiceClient"
//    2. Implement as the compiler (or VS refactor) tells you.
//    3. Set the GetCustomInstance property to a function that returns
//       the mock class.


#>
<#+
    void Generate(string @namespace, string className, string serviceName, WebService service, Callbacks callbacks = null)
    {
    #>
using System;
using System.ServiceModel;
#if SILVERLIGHT
using Gongchengshi.Silverlight;
#endif


namespace <#=@namespace#>
{
    /// <summary>
    /// IWebServiceContract is what the .NET service code will implement.
    /// </summary>
    [ServiceContract (<#+ if(callbacks != null) { #> CallbackContract = typeof(I<#=className#>CallbackContract) <#+ } #>) ]
    public interface I<#=className#>Contract
#if SILVERLIGHT
        : I<#=className#>ContractForSilverlightClient
#else
        : I<#=className#>ContractForDotNetServer
#endif
    { }

    <#+ if(callbacks != null) 
    { #>
    [ServiceContract]
    public interface I<#=className#>CallbackContract
    {
        <#+foreach(var function in callbacks.Functions)
        {#>
        [OperationContract (IsOneWay = true)]
        void <#=function.FunctionName#>(<#=function.RequestParameter(false)#>);
            
<#+     }
#>      
    }
<#+ } #>

    /// <summary>
    /// The .NET (web server) side of the contract.  This is the basic interface.
    /// </summary>
    [ServiceContract(Name = "I<#=className#>ContractForSilverlightClient"
	#if !SILVERLIGHT
	, SessionMode=SessionMode.Required
	#endif
	)]
    public interface I<#=className#>ContractForDotNetServer
    {
<#+
        foreach (var function in service.Functions) 
        {#>
        [OperationContract]
        <#=function.ResponseType#> <#=function.FunctionName#>(<#=function.RequestParameter(false)#>);
<#+     }    
#>
    }

    /// <summary>
    /// The Silverlight side of the contract.  
    /// This is necessary for the .NET ChannelFactory to hook up to the web service.  
    /// </summary>
    [ServiceContract]
    public interface I<#=className#>ContractForSilverlightClient
    {
<#+
        foreach (var function in service.Functions) 
        {#>
        [OperationContract(AsyncPattern = true)]
        IAsyncResult Begin<#=function.FunctionName#>(<#=function.RequestParameter(true)#> AsyncCallback callback, object iWebService);
        <#=function.ResponseType#> End<#=function.FunctionName#>(IAsyncResult result);
<#+     }    
#>
    }

    /// <summary>
    /// The IWebServiceClient is what Silverlight code will call directly.  This allows the use
    /// of a mock for testing Silverlight code.
    /// </summary>
    public interface I<#=className#>Client
    {
    <#+
        foreach (var function in service.Functions) 
        {
#>    
        void Begin<#=function.FunctionName#>(<#=function.RequestParameter(true)#> Action<#=function.ResponseActionParameter#> callback);
<#+     }    

        if(callbacks != null)
        {
        foreach(var function in callbacks.Functions)
        {#>
        event Action<#=function.RequestActionParameter#> <#=function.FunctionName#>Received;
            
<#+     }
        }
#>    
    }



#if SILVERLIGHT

    <#+ if(callbacks != null) 
    { #>
    public class <#=className#>CallbackContract : I<#=className#>CallbackContract
    {
        <#+ foreach(var function in callbacks.Functions) { #>
        public event Action<#=function.RequestActionParameter#> <#=function.FunctionName#>Received = delegate{}; 
        
        public void <#=function.FunctionName#>(<#=function.RequestParameter(false)#>)
        {
            <#=function.FunctionName#>Received(request);
        }       
        
<#+     }   #>
    }
<#+ } #>

    /// <summary>
    /// This helper class makes the Silverlight code clean.  It handles creating the channel factory and
    /// callbacks for the asynchronous web service calls.
    /// </summary>
    public class <#=className#>Client : <#+ if(callbacks != null) { #> 
		WebClient<I<#=className#>Contract, <#=className#>CallbackContract>, 
		<#+ } else { #>
		WebClient<I<#=className#>Contract>, 
		<#+ } #>
		I<#=className#>Client
    {
        private <#=className#>Client() : base("../<#=serviceName#>")
        { }

        public static I<#=className#>Client Instance
        {
            get
            {
                _instance = _instance ?? ((GetCustomInstance == null) ? new <#=className#>Client() : GetCustomInstance());
                return _instance;
            }
        }
        private static I<#=className#>Client _instance;
        public static Func<I<#=className#>Client> GetCustomInstance;

<#+
        foreach (var function in service.Functions) 
        {#>
        public void Begin<#=function.FunctionName#>(<#=function.RequestParameter(true)#> Action<#=function.ResponseActionParameter#> callback)
        {
            _webService.Begin<#=function.FunctionName#>(<#=function.RequestType == null ? string.Empty : "request,"#>
                a => HandleEnd(callback, ((I<#=className#>Contract)a.AsyncState).End<#=function.FunctionName#>, a), _webService);
        }    
<#+     } 
        
        if(callbacks != null)
        {                   
        foreach(var function in callbacks.Functions) { #>
        public event Action<#=function.RequestActionParameter#> <#=function.FunctionName#>Received 
        { 
            add { _callbackContract.<#=function.FunctionName#>Received += value; }
            remove { _callbackContract.<#=function.FunctionName#>Received -= value; }
        }
<#+     }} #>        
    }
#endif
}
<#+
    }
#>
